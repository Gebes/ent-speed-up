{{/*
Copyright 2019-present Facebook Inc. All rights reserved.
This source code is licensed under the Apache 2.0 license found
in the LICENSE file in the root directory of this source tree.
*/}}

{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "internal/ent" }}

{{- with extend $ "Package" "internal" -}}
	{{ template "header" . }}
{{ end }}

{{/* Additional dependencies injected to config. */}}
{{ $deps := list }}{{ with $.Config.Annotations }}{{ $deps = $.Config.Annotations.Dependencies }}{{ end }}

import (
  "log"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql/sqlgraph"
	stdent "entgo.io/ent"
  "{{ $.Config.Package }}"
  {{- range $dep := $deps }}
		{{ $dep.Type.PkgName }} "{{ $dep.Type.PkgPath }}"
	{{- end }}
)


type (
	// config is the configuration for the client and its builder.
	Config struct {
		// Driver used for executing database requests.
		Driver dialect.Driver
		// Debug enable a Debug logging.
		Debug bool
		// Log used for logging on Debug mode.
		Log func(...any)
		// Hooks to execute on mutations.
		Hooks *Hooks
		// interceptors to execute on queries.
		Inters *Inters
		{{- /* Additional dependency fields. */}}
		{{- range $dep := $deps }}
			{{ $dep.Field }} {{ $dep.Type }}
		{{- end }}
		{{- /* Support adding config fields from both global or dialect-specific templates. */}}
		{{- range $prefix := list "" (printf "dialect/%s/" $.Storage) }}
			{{- with $tmpls := matchTemplate (print $prefix "config/fields/*") }}
				{{- range $tmpl := $tmpls }}
					{{ xtemplate $tmpl $ }}
				{{- end }}
			{{- end }}
		{{- end }}
	}
)

// newConfig creates a new config for the client.
func NewConfig(opts ...ent.Option) Config {
	cfg := Config{Log: log.Println, Hooks: &Hooks{}, Inters: &Inters{}}
	cfg.Options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *Config) Options(opts ...ent.Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.Debug {
		c.Driver = dialect.Debug(c.Driver, c.Log)
	}
}

// Hooks and interceptors per client, for fast access.
type (
	Hooks struct {
		User []ent.Hook
	}
	Inters struct {
		User []ent.Interceptor
	}
)


// withHooks invokes the builder operation with the given hooks, if any.
func WithHooks[V ent.Value, M any, PM interface {
	*M
	ent.Mutation
}](ctx context.Context, exec func(context.Context) (V, error), mutation PM, hooks []ent.Hook) (value V, err error) {
	if len(hooks) == 0 {
		return exec(ctx)
	}
	var mut ent.Mutator = ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
		{{- /* redundant any() conversion is a workaround for golang/go#58633 */}}
		mutationT, ok := any(m).(PM)
		if !ok {
			return nil, fmt.Errorf("unexpected mutation type %T", m)
		}
		// Set the mutation to the builder.
		*mutation = *mutationT
		return exec(ctx)
	})
	for i := len(hooks) - 1; i >= 0; i-- {
		if hooks[i] == nil {
			return value, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
		}
		mut = hooks[i](mut)
	}
	v, err := mut.Mutate(ctx, mutation)
	if err != nil {
		return value, err
	}
	nv, ok := v.(V)
	if !ok {
		return value, fmt.Errorf("unexpected node type %T returned from %T", v, mutation)
	}
	return nv, nil
}


// setContextOp returns a new context with the given QueryContext attached (including its op) in case it does not exist.
func SetContextOp(ctx context.Context, qc *ent.QueryContext, op string) context.Context {
	if stdent.QueryFromContext(ctx) == nil {
		qc.Op = op
		ctx = stdent.NewQueryContext(ctx, qc)
	}
	return ctx
}

func QuerierAll[V ent.Value, Q interface {
	sqlAll(context.Context, ...QueryHook) (V, error)
}]() ent.Querier {
	return ent.QuerierFunc(func(ctx context.Context, q ent.Query) (ent.Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlAll(ctx)
	})
}

func QuerierCount[Q interface {
	sqlCount(context.Context) (int, error)
}]() ent.Querier {
	return ent.QuerierFunc(func(ctx context.Context, q ent.Query) (ent.Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlCount(ctx)
	})
}

func WithInterceptors[V ent.Value](ctx context.Context, q ent.Query, qr ent.Querier, inters []ent.Interceptor) (v V, err error) {
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	rv, err := qr.Query(ctx, q)
	if err != nil {
		return v, err
	}
	vt, ok := rv.(V)
	if !ok {
		return v, fmt.Errorf("unexpected type %T returned from %T. expected type: %T", vt, q, v)
	}
	return vt, nil
}

func ScanWithInterceptors[Q1 ent.Query, Q2 interface {
	sqlScan(context.Context, Q1, any) error
}](ctx context.Context, rootQuery Q1, selectOrGroup Q2, inters []ent.Interceptor, v any) error {
	rv := reflect.ValueOf(v)
	var qr ent.Querier = ent.QuerierFunc(func(ctx context.Context, q ent.Query) (ent.Value, error) {
		query, ok := q.(Q1)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		if err := selectOrGroup.sqlScan(ctx, query, v); err != nil {
			return nil, err
		}
		if k := rv.Kind(); k == reflect.Pointer && rv.Elem().CanInterface() {
			return rv.Elem().Interface(), nil
		}
		return v, nil
	})
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	vv, err := qr.Query(ctx, rootQuery)
	if err != nil {
		return err
	}
	switch rv2 := reflect.ValueOf(vv); {
	case rv.IsNil(), rv2.IsNil(), rv.Kind() != reflect.Pointer:
	case rv.Type() == rv2.Type():
		rv.Elem().Set(rv2.Elem())
	case rv.Elem().Type() == rv2.Type():
		rv.Elem().Set(rv2)
	}
	return nil
}

// queryHook describes an internal hook for the different sqlAll methods.
type QueryHook func(context.Context, *sqlgraph.QuerySpec)


{{ end }}
